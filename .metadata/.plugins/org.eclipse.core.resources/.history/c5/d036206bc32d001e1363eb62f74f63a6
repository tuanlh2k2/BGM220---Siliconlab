/***************************************************************************//**
 * @file
 * @brief Top level application functions
 *******************************************************************************
 * # License
 * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

/***************************************************************************//**
 * Initialize application.
 ******************************************************************************/
#include <st7735_spi.h>
#include "sl_spidrv_instances.h"
#include "glib.h"
#include "st7735.h"
#define DISPLAY_TEXT  0;

SPIDRV_HandleData_t handleData;
SPIDRV_Handle_t handle = &handleData;
uint8_t buffer[10];
// SPIDRV_Init_t initData = SPIDRV_MASTER_USART2;
static void oled_app_init(void);

static glib_context_t glib_context;
static uint32_t mode_display = DISPLAY_TEXT;

const uint8_t A[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // space.
		////////////////////////////////////////////////// + 1
		0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,  // 0
		0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,  // 1
		0x70, 0x88, 0x08, 0x70, 0x80, 0x80, 0xf8, 0x00,  // 2
		0xf8, 0x08, 0x10, 0x30, 0x08, 0x88, 0x70, 0x00,  // 3
		0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x10, 0x00,  // 4
		0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,  // 5
		0x38, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,  // 6
		0xf8, 0x08, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00,  // 7
		0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,  // 8
		0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0xe0, 0x00,  // 9
		/////////////////////////////////////////////////// + 10
		0x20, 0x50, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x00,   //A
		0xf0, 0x88, 0x88, 0xf0, 0x88, 0x88, 0xf0, 0x00,  // B
		0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70, 0x00,  // C
		0xf0, 0x88, 0x88, 0x88, 0x88, 0x88, 0xf0, 0x00,  // D
		0xf8, 0x80, 0x80, 0xf0, 0x80, 0x80, 0xf8, 0x00,  // E
		0xf8, 0x80, 0x80, 0xf0, 0x80, 0x80, 0x80, 0x00,  // F
		0x78, 0x88, 0x80, 0x80, 0x98, 0x88, 0x78, 0x00,  // G
		0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,  // H
		0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,  // I
		0x38, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00,  // J
		0x88, 0x90, 0xa0, 0xc0, 0xa0, 0x90, 0x88, 0x00,  // K
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf8, 0x00,  // L
		0x88, 0xd8, 0xa8, 0xa8, 0xa8, 0x88, 0x88, 0x00,  // M
		0x88, 0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x00,  // N
		0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,  // O
		0xf0, 0x88, 0x88, 0xf0, 0x80, 0x80, 0x80, 0x00,  // P
		0x70, 0x88, 0x88, 0x88, 0xa8, 0x90, 0x68, 0x00,  // Q
		0xf0, 0x88, 0x88, 0xf0, 0xa0, 0x90, 0x88, 0x00,  // R
		0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,  // S
		0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,  // T
		0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,  // U
		0x88, 0x88, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,  // V
		0x88, 0x88, 0x88, 0xa8, 0xa8, 0xa8, 0x50, 0x00,  // W
		0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,  // X
		0x88, 0x88, 0x50, 0x20, 0x20, 0x20, 0x20, 0x00,  // Y
		0xf8, 0x08, 0x10, 0x70, 0x40, 0x80, 0xf8, 0x00,  // Z

};


void inhinhanh()
{
	draw_character(0, 0, '1');
	draw_character(8, 0, '2');
	draw_character(16, 0, '3');
}

void draw_character(int coordinate_x, int coordinate_y, char data)
{
	// find code data.
	uint8_t offset = 0;
	if (data >= 'A') {
		offset = (data) - 'A' + 11;
	} else if(data >= '0' && data <= '9'){
		offset = (data) - '0' + 1;
	} else if (data == ' ') {
		offset = 0;
	}

	// draw.
	for (int i = 0; i < 8; i++) {
		uint16_t pixelData = A[i + offset * 8];
		// Duyệt qua từng cột pixel trong font chữ 6x8
		for (int j = 0; j < 8; j++) {
			// Kiểm tra nếu bit tại vị trí j của pixelData bằng 1 (pixel bật)
			if ((pixelData >> (7 - j)) & 0x01) {
				// Vẽ pixel bật tại tọa độ (x + j, y + i) với màu của bạn (ví dụ: 0xFFFF - màu trắng)
				st7735_drawPixel(coordinate_x + j, coordinate_y + i, 0xFFFF);
			}
			// Nếu bit tại vị trí j của pixelData bằng 0 (pixel tắt)
			else {
				// Vẽ pixel tắt tại tọa độ (x + j, y + i) với màu của bạn (ví dụ: 0x0000 - màu đen)
				st7735_drawPixel(coordinate_x + j, coordinate_y + i, 0x0000);
			}
		}
	}
}

void draw_string(int coordinate_x, int coordinate_y, const char* str)
{
	uint8_t x = coordinate_x;
	while (*str) {
		draw_character(x, coordinate_y, *str);

		/* Adjust x and y coordinate */
		x += 8;

		// Next char
		str++;
	}
}

void app_init(void)
{
	glib_init();
	st7735_set_window(0,0,160, 128);
}

/***************************************************************************//**
 * App ticking function.
 ******************************************************************************/
void app_process_action(void)
{
	//inhinhanh();
	draw_string(0, 0, "DEVICE 1");
	draw_string(0, 9, "TEMPERATURE 21");
}

/***************************************************************************//**
 * Initialize example.
 ******************************************************************************/
static void oled_app_init(void)
{
	/* Initialize the display */
	glib_init();

	glib_context.backgroundColor = White;
	glib_context.foregroundColor = White;
	glib_context.font = glib_font_6x8;
	/* Fill lcd with background color */
	glib_clear(&glib_context);
	// glib_draw_line(&glib_context, 0, 0, 6, 6);
}
